
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>2. Starting Out  Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.23">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="03-types-and-typeclasses.html" />
    
    
    <link rel="prev" href="01-first-things-first.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="01-first-things-first.html">
            
                <a href="01-first-things-first.html">
            
                    
                    1. First-Things-First
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="02-starting-out.html">
            
                <a href="02-starting-out.html">
            
                    
                    2. Starting Out 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="03-types-and-typeclasses.html">
            
                <a href="03-types-and-typeclasses.html">
            
                    
                    3. Types and Typeclasses
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="04-syntax-in-functions.html">
            
                <a href="04-syntax-in-functions.html">
            
                    
                    4. Syntax in Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="05-recursion.html">
            
                <a href="05-recursion.html">
            
                    
                    5. Recursion
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="06-higher-order-functions.html">
            
                <a href="06-higher-order-functions.html">
            
                    
                    6. Higher Order Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="07-modules.html">
            
                <a href="07-modules.html">
            
                    
                    7. Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="08-making-our-own-types-and-typeclasses.html">
            
                <a href="08-making-our-own-types-and-typeclasses.html">
            
                    
                    8. Making Our Own Types and Typeclasses
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="09-input-and-output.html">
            
                <a href="09-input-and-output.html">
            
                    
                    9. Input and Output
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="10-functionally-solving-problems.html">
            
                <a href="10-functionally-solving-problems.html">
            
                    
                    10. Functionally Solving Problems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="11-functors-applicative-functors-and-monoids.html">
            
                <a href="11-functors-applicative-functors-and-monoids.html">
            
                    
                    11. Functors, Applicative Functors and Monoids
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="12-a-fistful-of-monads.html">
            
                <a href="12-a-fistful-of-monads.html">
            
                    
                    12. A Fistful of Monads
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="13-for-a-few-monads-more.html">
            
                <a href="13-for-a-few-monads-more.html">
            
                    
                    13. For a Few Monads More
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="14-zippers.html">
            
                <a href="14-zippers.html">
            
                    
                    14. Zippers
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >2. Starting Out </a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="starting-out">Starting Out</h1>
<h2 id="ready-set-go">Ready, set, go!</h2>
<p><img src="img/startingout.png" alt="egg"> Alright, let&apos;s get
started! If you&apos;re the sort of horrible person who doesn&apos;t read
introductions to things and you skipped it, you might want to read the
last section in the introduction anyway because it explains what you
need to follow this tutorial and how we&apos;re going to load functions. The
first thing we&apos;re going to do is run ghc&apos;s interactive mode and call
some function to get a very basic feel for haskell. Open your terminal
and type in <code>ghci</code>. You will be greeted with something like this.</p>
<pre><code class="lang-haskell"><span class="hljs-type">GHCi</span>, version <span class="hljs-number">6.8</span><span class="hljs-number">.2</span>: http://www.haskell.org/ghc/  :? for help
<span class="hljs-type">Loading</span> package base ... linking ... done.
<span class="hljs-type">Prelude</span>&gt;
</code></pre>
<p>Congratulations, you&apos;re in GHCI! The prompt here is <code>Prelude&gt;</code> but
because it can get longer when you load stuff into the session, we&apos;re
going to use <code>ghci&gt;</code>. If you want to have the same prompt, just type in
<code>:set prompt &quot;ghci&gt; &quot;</code>.</p>
<p>Here&apos;s some simple arithmetic.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-number">2</span> + <span class="hljs-number">15</span>
<span class="hljs-number">17</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">49</span> * <span class="hljs-number">100</span>
<span class="hljs-number">4900</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1892</span> - <span class="hljs-number">1472</span>
<span class="hljs-number">420</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">5</span> / <span class="hljs-number">2</span>
<span class="hljs-number">2.5</span>
<span class="hljs-title">ghci</span>&gt;
</code></pre>
<p>This is pretty self-explanatory. We can also use several operators on
one line and all the usual precedence rules are obeyed. We can use
parentheses to make the precedence explicit or to change it.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; (<span class="hljs-number">50</span> * <span class="hljs-number">100</span>) - <span class="hljs-number">4999</span>
<span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">50</span> * <span class="hljs-number">100</span> - <span class="hljs-number">4999</span>
<span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">50</span> * (<span class="hljs-number">100</span> - <span class="hljs-number">4999</span>)
<span class="hljs-number">-244950</span>
</code></pre>
<p>Pretty cool, huh? Yeah, I know it&apos;s not but bear with me. A little
pitfall to watch out for here is negating numbers. If we want to have a
negative number, it&apos;s always best to surround it with parentheses. Doing
<code>5 * -3</code> will make GHCI yell at you but doing <code>5 * (-3)</code> will work just
fine.</p>
<p>Boolean algebra is also pretty straightforward. As you probably know, <code>&amp;&amp;</code>
means a boolean <em>and</em>, <code>||</code> means a boolean <em>or</em>. <code>not</code> negates a <code>True</code> or a
<code>False</code>.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-type">True</span> &amp;&amp; <span class="hljs-type">False</span>
<span class="hljs-type">False</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">True</span> &amp;&amp; <span class="hljs-type">True</span>
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">False</span> || <span class="hljs-type">True</span>
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; not <span class="hljs-type">False</span>
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; not (<span class="hljs-type">True</span> &amp;&amp; <span class="hljs-type">True</span>)
<span class="hljs-type">False</span>
</code></pre>
<p>Testing for equality is done like so.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-number">5</span> == <span class="hljs-number">5</span>
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
<span class="hljs-type">False</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">5</span> /= <span class="hljs-number">5</span>
<span class="hljs-type">False</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">5</span> /= <span class="hljs-number">4</span>
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-string">&quot;hello&quot;</span> == <span class="hljs-string">&quot;hello&quot;</span>
<span class="hljs-type">True</span>
</code></pre>
<p>What about doing <code>5 + &quot;llama&quot;</code> or <code>5 == True</code>? Well, if we try the first
snippet, we get a big scary error message!</p>
<pre><code class="lang-haskell"><span class="hljs-type">No</span> <span class="hljs-keyword">instance</span> for (<span class="hljs-type">Num</span> [<span class="hljs-type">Char</span>])
<span class="hljs-title">arising</span> from a use <span class="hljs-keyword">of</span> `+&apos; at &lt;interactive&gt;:<span class="hljs-number">1</span>:<span class="hljs-number">0</span><span class="hljs-number">-9</span>
<span class="hljs-type">Possible</span> fix: add an <span class="hljs-keyword">instance</span> declaration for (<span class="hljs-type">Num</span> [<span class="hljs-type">Char</span>])
<span class="hljs-type">In</span> the expression: <span class="hljs-number">5</span> + <span class="hljs-string">&quot;llama&quot;</span>
<span class="hljs-type">In</span> the definition <span class="hljs-keyword">of</span> `it&apos;: it = <span class="hljs-number">5</span> + <span class="hljs-string">&quot;llama&quot;</span>
</code></pre>
<p>Yikes! What GHCI is telling us here is that <code>&quot;llama&quot;</code> is not a number and
so it doesn&apos;t know how to add it to 5. Even if it wasn&apos;t <code>&quot;llama&quot;</code> but
<code>&quot;four&quot;</code> or <code>&quot;4&quot;</code>, Haskell still wouldn&apos;t consider it to be a number. <code>+</code>
expects its left and right side to be numbers. If we tried to do <code>True == 5</code>,
GHCI would tell us that the types don&apos;t match. Whereas <code>+</code> works only
on things that are considered numbers, <code>==</code> works on any two things that
can be compared. But the catch is that they both have to be the same
type of thing. You can&apos;t compare apples and oranges. We&apos;ll take a closer
look at types a bit later. Note: you can do <code>5 + 4.0</code> because <code>5</code> is sneaky
and can act like an integer or a floating-point number. <code>4.0</code> can&apos;t act
like an integer, so <code>5</code> is the one that has to adapt.</p>
<p>You may not have known it but we&apos;ve been using functions now all along.
For instance, <code>*</code> is a function that takes two numbers and multiplies
them. As you&apos;ve seen, we call it by sandwiching it between them. This is
what we call an <em>infix</em> function. Most functions that aren&apos;t used with
numbers are <em>prefix</em> functions. Let&apos;s take a look at them.</p>
<p><img src="img/ringring.png" alt="phoen"></p>
<p>Functions are usually prefix so from now on we won&apos;t explicitly state that a function is of the prefix form, we&apos;ll just assume it. In most imperative
languages functions are called by writing the function name and then
writing its parameters in parentheses, usually separated by commas. In
Haskell, functions are called by writing the function name, a space and
then the parameters, separated by spaces. For a start, we&apos;ll try calling
one of the most boring functions in Haskell.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; succ <span class="hljs-number">8</span>
<span class="hljs-number">9</span>
</code></pre>
<p>The <code>succ</code> function takes anything that has a defined successor and
returns that successor. As you can see, we just separate the function
name from the parameter with a space. Calling a function with several
parameters is also simple. The functions <code>min</code> and <code>max</code> take two things
that can be put in an order (like numbers!). <code>min</code> returns the one that&apos;s
lesser and <code>max</code> returns the one that&apos;s greater. See for yourself:</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; min <span class="hljs-number">9</span> <span class="hljs-number">10</span>
<span class="hljs-number">9</span>
<span class="hljs-title">ghci</span>&gt; min <span class="hljs-number">3.4</span> <span class="hljs-number">3.2</span>
<span class="hljs-number">3.2</span>
<span class="hljs-title">ghci</span>&gt; max <span class="hljs-number">100</span> <span class="hljs-number">101</span>
<span class="hljs-number">101</span>
</code></pre>
<p>Function application (calling a function by putting a space after it and
then typing out the parameters) has the highest precedence of them all.
What that means for us is that these two statements are equivalent.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; succ <span class="hljs-number">9</span> + max <span class="hljs-number">5</span> <span class="hljs-number">4</span> + <span class="hljs-number">1</span>
<span class="hljs-number">16</span>
<span class="hljs-title">ghci</span>&gt; (succ <span class="hljs-number">9</span>) + (max <span class="hljs-number">5</span> <span class="hljs-number">4</span>) + <span class="hljs-number">1</span>
<span class="hljs-number">16</span>
</code></pre>
<p>However, if we wanted to get the successor of the product of numbers 9
and 10, we couldn&apos;t write <code>succ 9 * 10</code> because that would get the
successor of 9, which would then be multiplied by 10. So 100. We&apos;d have
to write <code>succ (9 * 10)</code> to get 91.</p>
<p>If a function takes two parameters, we can also call it as an infix
function by surrounding it with backticks. For instance, the <code>div</code>
function takes two integers and does integral division between them.
Doing <code>div 92 10</code> results in a 9. But when we call it like that, there may
be some confusion as to which number is doing the division and which one
is being divided. So we can call it as an infix function by doing
<code>92 `div` 10</code> and suddenly it&apos;s much clearer.</p>
<p>Lots of people who come from imperative languages tend to stick to the
notion that parentheses should denote function application. For example,
in C, you use parentheses to call functions like <code>foo()</code>, <code>bar(1)</code> or
<code>baz(3, &quot;haha&quot;)</code>. Like we said, spaces are used for function application in
Haskell. So those functions in Haskell would be <code>foo</code>, <code>bar 1</code> and <code>baz 3
&quot;haha&quot;</code>. So if you see something like <code>bar (bar 3)</code>, it doesn&apos;t mean that
<code>bar</code> is called with <code>bar</code> and <code>3</code> as parameters. It means that we first call
the function <code>bar</code> with <code>3</code> as the parameter to get some number and then we
call <code>bar</code> again with that number. In C, that would be something like
<code>bar(bar(3))</code>.</p>
<h2 id="babys-first-functions">Baby&apos;s first functions</h2>
<p>In the previous section we got a basic feel for calling functions. Now
let&apos;s try making our own! Open up your favorite text editor and punch in
this function that takes a number and multiplies it by two.</p>
<pre><code class="lang-haskell"><span class="hljs-title">doubleMe</span> x = x + x
</code></pre>
<p>Functions are defined in a similar way that they are called. The
function name is followed by parameters separated by spaces. But when
defining functions, there&apos;s a <code>=</code> and after that we define what the
function does. Save this as <code>baby.hs</code> or something. Now navigate to where
it&apos;s saved and run <code>ghci</code> from there. Once inside GHCI, do <code>:l baby</code>. Now
that our script is loaded, we can play with the function that we
defined.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; :l baby
[<span class="hljs-number">1</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span>] <span class="hljs-type">Compiling</span> <span class="hljs-type">Main</span>             ( baby.hs, interpreted )
<span class="hljs-type">Ok</span>, modules loaded: <span class="hljs-type">Main</span>.
<span class="hljs-title">ghci</span>&gt; doubleMe <span class="hljs-number">9</span>
<span class="hljs-number">18</span>
<span class="hljs-title">ghci</span>&gt; doubleMe <span class="hljs-number">8.3</span>
<span class="hljs-number">16.6</span>
</code></pre>
<p>Because <code>+</code> works on integers as well as on floating-point numbers
(anything that can be considered a number, really), our function also
works on any number. Let&apos;s make a function that takes two numbers and
multiplies each by two and then adds them together.</p>
<pre><code class="lang-haskell"><span class="hljs-title">doubleUs</span> x y = x*<span class="hljs-number">2</span> + y*<span class="hljs-number">2</span>
</code></pre>
<p>Simple. We could have also defined it as <code>doubleUs x y = x + x + y + y</code>.
Testing it out produces pretty predictable results (remember to append
this function to the <code>baby.hs</code> file, save it and then do <code>:l baby</code> inside
GHCI).</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; doubleUs <span class="hljs-number">4</span> <span class="hljs-number">9</span>
<span class="hljs-number">26</span>
<span class="hljs-title">ghci</span>&gt; doubleUs <span class="hljs-number">2.3</span> <span class="hljs-number">34.2</span>
<span class="hljs-number">73.0</span>
<span class="hljs-title">ghci</span>&gt; doubleUs <span class="hljs-number">28</span> <span class="hljs-number">88</span> + doubleMe <span class="hljs-number">123</span>
<span class="hljs-number">478</span>
</code></pre>
<p>As expected, you can call your own functions from other functions that
you made. With that in mind, we could redefine <code>doubleUs</code> like this:</p>
<pre><code class="lang-haskell"><span class="hljs-title">doubleUs</span> x y = doubleMe x + doubleMe y
</code></pre>
<p>This is a very simple example of a common pattern you will see
throughout Haskell. Making basic functions that are obviously correct
and then combining them into more complex functions. This way you also
avoid repetition. What if some mathematicians figured out that 2 is
actually 3 and you had to change your program? You could just redefine
<code>doubleMe</code> to be <code>x + x + x</code> and since <code>doubleUs</code> calls <code>doubleMe</code>, it would
automatically work in this strange new world where 2 is 3.</p>
<p>Functions in Haskell don&apos;t have to be in any particular order, so it
doesn&apos;t matter if you define <code>doubleMe</code> first and then <code>doubleUs</code> or if you
do it the other way around.</p>
<p>Now we&apos;re going to make a function that multiplies a number by 2 but
only if that number is smaller than or equal to 100 because numbers
bigger than 100 are big enough as it is!</p>
<pre><code class="lang-haskell"><span class="hljs-title">doubleSmallNumber</span> x = <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span>
                        <span class="hljs-keyword">then</span> x
                        <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span>
</code></pre>
<p><img src="img/baby.png" alt="this is you"></p>
<p>Right here we introduced Haskell&apos;s if statement. You&apos;re probably
familiar with if statements from other languages. The difference between
Haskell&apos;s if statement and if statements in imperative languages is that
the else part is mandatory in Haskell. In imperative languages you can
just skip a couple of steps if the condition isn&apos;t satisfied but in
Haskell every expression and function must return something. We could
have also written that if statement in one line but I find this way more
readable. Another thing about the if statement in Haskell is that it is
an <em>expression</em>. An expression is basically a piece of code that returns
a value. <code>5</code> is an expression because it returns 5, <code>4 + 8</code> is an
expression, <code>x + y</code> is an expression because it returns the sum of <code>x</code> and
<code>y</code>. Because the else is mandatory, an if statement will always return
something and that&apos;s why it&apos;s an expression. If we wanted to add one to
every number that&apos;s produced in our previous function, we could have
written its body like this.</p>
<pre><code class="lang-haskell"><span class="hljs-title">doubleSmallNumber&apos;</span> x = (<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span>) + <span class="hljs-number">1</span>
</code></pre>
<p>Had we omitted the parentheses, it would have added one only if <code>x</code> wasn&apos;t
greater than 100. Note the <code>&apos;</code> at the end of the function name. That
apostrophe doesn&apos;t have any special meaning in Haskell&apos;s syntax. It&apos;s a
valid character to use in a function name. We usually use <code>&apos;</code> to either
denote a strict version of a function (one that isn&apos;t lazy) or a
slightly modified version of a function or a variable. Because <code>&apos;</code> is a
valid character in functions, we can make a function like this.</p>
<pre><code class="lang-haskell"><span class="hljs-title">conanO&apos;Brien</span> = <span class="hljs-string">&quot;It&apos;s a-me, Conan O&apos;Brien!&quot;</span>
</code></pre>
<p>There are two noteworthy things here. The first is that in the function
name we didn&apos;t capitalize Conan&apos;s name. That&apos;s because functions can&apos;t
begin with uppercase letters. We&apos;ll see why a bit later. The second
thing is that this function doesn&apos;t take any parameters. When a function
doesn&apos;t take any parameters, we usually say it&apos;s a <em>definition</em> (or a
<em>name</em>). Because we can&apos;t change what names (and functions) mean once
we&apos;ve defined them, <code>conanO&apos;Brien</code> and the string <code>&quot;It&apos;s a-me, Conan
O&apos;Brien!&quot;</code> can be used interchangeably.</p>
<h2 id="an-intro-to-lists">An intro to lists</h2>
<p><img src="img/list.png" alt="BUY A DOG"> Much like shopping
lists in the real world, lists in Haskell are very useful. It&apos;s the most
used data structure and it can be used in a multitude of different ways
to model and solve a whole bunch of problems. Lists are SO awesome. In
this section we&apos;ll look at the basics of lists, strings (which are
lists) and list comprehensions.</p>
<p>In Haskell, lists are a <em>homogenous</em> data structure. It stores several
elements of the same type. That means that we can have a list of
integers or a list of characters but we can&apos;t have a list that has a few
integers and then a few characters. And now, a list!</p>
<blockquote>
<p><em>Note</em>: We can use the <code>let</code> keyword to define a name right in GHCI. Doing
<code>let a = 1</code> inside GHCI is the equivalent of writing <code>a = 1</code> in a script and
then loading it.</p>
</blockquote>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> lostNumbers = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">23</span>,<span class="hljs-number">42</span>]
<span class="hljs-title">ghci</span>&gt; lostNumbers
[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">23</span>,<span class="hljs-number">42</span>]
</code></pre>
<p>As you can see, lists are denoted by square brackets and the values in
the lists are separated by commas. If we tried a list like
<code>[1,2,&apos;a&apos;,3,&apos;b&apos;,&apos;c&apos;,4]</code>, Haskell would complain that characters (which
are, by the way, denoted as a character between single quotes) are not
numbers. Speaking of characters, strings are just lists of characters.
<code>&quot;hello&quot;</code> is just syntactic sugar for <code>[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]</code>. Because
strings are lists, we can use list functions on them, which is really
handy.</p>
<p>A common task is putting two lists together. This is done by using the
<code>++</code> operator.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ++ [<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]
<span class="hljs-title">ghci</span>&gt; <span class="hljs-string">&quot;hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world&quot;</span>
<span class="hljs-string">&quot;hello world&quot;</span>
<span class="hljs-title">ghci</span>&gt; [&apos;w&apos;,&apos;o&apos;] ++ [&apos;o&apos;,&apos;t&apos;]
<span class="hljs-string">&quot;woot&quot;</span>
</code></pre>
<p>Watch out when repeatedly using the <code>++</code> operator on long strings. When
you put together two lists (even if you append a singleton list to a
list, for instance: <code>[1,2,3] ++ [4]</code>), internally, Haskell has to walk
through the whole list on the left side of <code>++</code>. That&apos;s not a problem when
dealing with lists that aren&apos;t too big. But putting something at the end
of a list that&apos;s fifty million entries long is going to take a while.
However, putting something at the beginning of a list using the <code>:</code>
operator (also called the cons operator) is instantaneous.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; &apos;<span class="hljs-type">A&apos;</span>:<span class="hljs-string">&quot; SMALL CAT&quot;</span>
<span class="hljs-string">&quot;A SMALL CAT&quot;</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">5</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
</code></pre>
<p>Notice how <code>:</code> takes a number and a list of numbers or a character and a
list of characters, whereas <code>++</code> takes two lists. Even if you&apos;re adding an
element to the end of a list with <code>++</code>, you have to surround it with
square brackets so it becomes a list.</p>
<p><code>[1,2,3]</code> is actually just syntactic sugar for <code>1:2:3:[]</code>. <code>[]</code> is an empty
list. If we prepend <code>3</code> to it, it becomes <code>[3]</code>. If we prepend <code>2</code> to that, it
becomes <code>[2,3]</code>, and so on.</p>
<blockquote>
<p><em>Note:</em> <code>[]</code>, <code>[[]]</code> and <code>[[],[],[]]</code> are all different things. The first one
is an empty list, the second one is a list that contains one empty list, the
third one is a list that contains three empty lists.</p>
</blockquote>
<p>If you want to get an element out of a list by index, use <code>!!</code>. The
indices start at 0.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-string">&quot;Steve Buscemi&quot;</span> !! <span class="hljs-number">6</span>
&apos;<span class="hljs-type">B&apos;</span>
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">9.4</span>,<span class="hljs-number">33.2</span>,<span class="hljs-number">96.2</span>,<span class="hljs-number">11.2</span>,<span class="hljs-number">23.25</span>] !! <span class="hljs-number">1</span>
<span class="hljs-number">33.2</span>
</code></pre>
<p>But if you try to get the sixth element from a list that only has four
elements, you&apos;ll get an error so be careful!</p>
<p>Lists can also contain lists. They can also contain lists that contain
lists that contain lists â¦</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> b = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
<span class="hljs-title">ghci</span>&gt; b
[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
<span class="hljs-title">ghci</span>&gt; b ++ [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]
[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>]:b
[[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
<span class="hljs-title">ghci</span>&gt; b !! <span class="hljs-number">2</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
</code></pre>
<p>The lists within a list can be of different lengths but they can&apos;t be of
different types. Just like you can&apos;t have a list that has some
characters and some numbers, you can&apos;t have a list that has some lists
of characters and some lists of numbers.</p>
<p>Lists can be compared if the stuff they contain can be compared. When
using <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> to compare lists, they are compared in
lexicographical order. First the heads are compared. If they are equal
then the second elements are compared, etc.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>]
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] == [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]
<span class="hljs-type">True</span>
</code></pre>
<p>What else can you do with lists? Here are some basic functions that
operate on lists.</p>
<p><code>head</code> takes a list and returns its head. The head of a list is basically
its first element.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; head [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
<span class="hljs-number">5</span>
</code></pre>
<p><code>tail</code> takes a list and returns its tail. In other words, it chops off a
list&apos;s head.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; tail [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
</code></pre>
<p><code>last</code> takes a list and returns its last element.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; last [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
<span class="hljs-number">1</span>
</code></pre>
<p><code>init</code> takes a list and returns everything except its last element.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; init [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]
</code></pre>
<p>If we think of a list as a monster, here&apos;s what&apos;s what.</p>
<p><img src="img/listmonster.png" alt="list monster"></p>
<p>But what happens if we try to get the head of an empty list?</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; head []
*** <span class="hljs-type">Exception</span>: <span class="hljs-type">Prelude</span>.head: empty list
</code></pre>
<p>Oh my! It all blows up in our face! If there&apos;s no monster, it doesn&apos;t
have a head. When using <code>head</code>, <code>tail</code>, <code>last</code> and <code>init</code>, be careful not to use
them on empty lists. This error cannot be caught at compile time so it&apos;s
always good practice to take precautions against accidentally telling
Haskell to give you some elements from an empty list.</p>
<p><code>length</code> takes a list and returns its length, obviously.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; length [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
<span class="hljs-number">5</span>
</code></pre>
<p><code>null</code> checks if a list is empty. If it is, it returns <code>True</code>, otherwise it
returns <code>False</code>. Use this function instead of <code>xs == []</code> (if you have a list
called <code>xs</code>)</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; null [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-type">False</span>
<span class="hljs-title">ghci</span>&gt; null []
<span class="hljs-type">True</span>
</code></pre>
<p><code>reverse</code> reverses a list.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; reverse [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
</code></pre>
<p><code>take</code> takes number and a list. It extracts that many elements from the
beginning of the list. Watch.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">3</span> [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]
<span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">1</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>]
[<span class="hljs-number">3</span>]
<span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">5</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">0</span> [<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>]
[]
</code></pre>
<p>See how if we try to take more elements than there are in the list, it
just returns the list. If we try to take 0 elements, we get an empty
list.</p>
<p><code>drop</code> works in a similar way, only it drops the number of elements from
the beginning of a list.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; drop <span class="hljs-number">3</span> [<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-title">ghci</span>&gt; drop <span class="hljs-number">0</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-title">ghci</span>&gt; drop <span class="hljs-number">100</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
[]
</code></pre>
<p><code>maximum</code> takes a list of stuff that can be put in some kind of order and
returns the biggest element.</p>
<p><code>minimum</code> returns the smallest.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; minimum [<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; maximum [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-number">9</span>
</code></pre>
<p><code>sum</code> takes a list of numbers and returns their sum.</p>
<p><code>product</code> takes a list of numbers and returns their product.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; sum [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]
<span class="hljs-number">31</span>
<span class="hljs-title">ghci</span>&gt; product [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
<span class="hljs-number">24</span>
<span class="hljs-title">ghci</span>&gt; product [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]
<span class="hljs-number">0</span>
</code></pre>
<p><code>elem</code> takes a thing and a list of things and tells us if that thing is an
element of the list. It&apos;s usually called as an infix function because
it&apos;s easier to read that way.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-number">4</span> `elem` [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-type">True</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">10</span> `elem` [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-type">False</span>
</code></pre>
<p>Those were a few basic functions that operate on lists. We&apos;ll take a
look at more list functions <a href="#data-list">later</a></p>
<h2 id="texas-ranges">Texas ranges</h2>
<p><img src="img/cowboy.png" alt="draw"> What if we want a list
of all numbers between 1 and 20? Sure, we could just type them all out
but obviously that&apos;s not a solution for gentlemen who demand excellence
from their programming languages. Instead, we&apos;ll use ranges. Ranges are
a way of making lists that are arithmetic sequences of elements that can
be enumerated. Numbers can be enumerated. One, two, three, four, etc.
Characters can also be enumerated. The alphabet is an enumeration of
characters from A to Z. Names can&apos;t be enumerated. What comes after
&quot;John&quot;? I don&apos;t know.</p>
<p>To make a list containing all the natural numbers from 1 to 20, you just
write <code>[1..20]</code>. That is the equivalent of writing
<code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code> and there&apos;s no
difference between writing one or the other except that writing out long
enumeration sequences manually is stupid.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">1.</span><span class="hljs-number">.20</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>]
<span class="hljs-title">ghci</span>&gt; [&apos;a&apos;..&apos;z&apos;]
<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="hljs-title">ghci</span>&gt; [&apos;<span class="hljs-type">K&apos;</span>..&apos;<span class="hljs-type">Z&apos;</span>]
<span class="hljs-string">&quot;KLMNOPQRSTUVWXYZ&quot;</span>
</code></pre>
<p>Ranges are cool because you can also specify a step. What if we want all
even numbers between 1 and 20? Or every third number between 1 and 20?</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4.</span><span class="hljs-number">.20</span>]
[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">6.</span><span class="hljs-number">.20</span>]
[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]
</code></pre>
<p>It&apos;s simply a matter of separating the first two elements with a comma
and then specifying what the upper limit is. While pretty smart, ranges
with steps aren&apos;t as smart as some people expect them to be. You can&apos;t
do <code>[1,2,4,8,16..100]</code> and expect to get all the powers of 2. Firstly
because you can only specify one step. And secondly because some
sequences that aren&apos;t arithmetic are ambiguous if given only by a few of
their first terms.</p>
<p>To make a list with all the numbers from 20 to 1, you can&apos;t just do
<code>[20..1]</code>, you have to do <code>[20,19..1]</code>.</p>
<p>Watch out when using floating point numbers in ranges! Because they are
not completely precise (by definition), their use in ranges can yield
some pretty funky results.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span> .. <span class="hljs-number">1</span>]
[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">0.8999999999999999</span>,<span class="hljs-number">1.0999999999999999</span>]
</code></pre>
<p>My advice is not to use them in list ranges.</p>
<p>You can also use ranges to make infinite lists by just not specifying an
upper limit. Later we&apos;ll go into more detail on infinite lists. For now,
let&apos;s examine how you would get the first 24 multiples of 13. Sure, you
could do <code>[13,26..24*13]</code>. But there&apos;s a better way: <code>take 24 [13,26..]</code>.
Because Haskell is lazy, it won&apos;t try to evaluate the infinite list
immediately because it would never finish. It&apos;ll wait to see what you
want to get out of that infinite lists. And here it sees you just want
the first 24 elements and it gladly obliges.</p>
<p>A handful of functions that produce infinite lists:</p>
<p><code>cycle</code> takes a list and cycles it into an infinite list. If you just try
to display the result, it will go on forever so you have to slice it off
somewhere.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
<span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">12</span> (cycle <span class="hljs-string">&quot;LOL &quot;</span>)
<span class="hljs-string">&quot;LOL LOL LOL &quot;</span>
</code></pre>
<p><code>repeat</code> takes an element and produces an infinite list of just that
element. It&apos;s like cycling a list with only one element.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; take <span class="hljs-number">10</span> (repeat <span class="hljs-number">5</span>)
[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]
</code></pre>
<p>Although it&apos;s simpler to just use the <code>replicate</code> function if you want
some number of the same element in a list. <code>replicate 3 10</code> returns
<code>[10,10,10]</code>.</p>
<p><a name="im-a-list-comprehension"></a></p>
<h2 id="im-a-list-comprehension">I&apos;m a list comprehension</h2>
<p><img src="img/kermit.png" alt="frog"></p>
<p>If you&apos;ve ever taken a
course in mathematics, you&apos;ve probably run into <em>set comprehensions</em>.
They&apos;re normally used for building more specific sets out of general
sets. A basic comprehension for a set that contains the first ten even
natural numbers is <img src="img/setnotation.png" alt="set
notation">. The part before
the pipe is called the output function, <code>x</code> is the variable, <code>N</code> is the
input set and <code>x &lt;= 10</code> is the predicate. That means that the set
contains the doubles of all natural numbers that satisfy the predicate. You
would read this as, &quot;The set of all <code>2x</code> such that <code>x</code> is in the set of all
natural numbers, and <code>x</code> is less than or equal to 10.&quot;</p>
<p>If we wanted to write that in Haskell, we could do something like <code>take
10 [2,4..]</code>. But what if we didn&apos;t want doubles of the first 10 natural
numbers but some kind of more complex function applied on them? We could
use a list comprehension for that. List comprehensions are very similar
to set comprehensions. We&apos;ll stick to getting the first 10 even numbers
for now. The list comprehension we could use is <code>[x*2 | x &lt;- [1..10]]</code>.
<code>x</code> is drawn from <code>[1..10]</code> and for every element in <code>[1..10]</code> (which we have
bound to <code>x</code>), we get that element, only doubled. Here&apos;s that
comprehension in action.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [x*<span class="hljs-number">2</span> | x &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>]]
[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]
</code></pre>
<p>As you can see, we get the desired results. Now let&apos;s add a condition
(or a predicate) to that comprehension. Predicates go after the binding
parts and are separated from them by a comma. Let&apos;s say we want only the
elements which, doubled, are greater than or equal to 12.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [x*<span class="hljs-number">2</span> | x &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], x*<span class="hljs-number">2</span> &gt;= <span class="hljs-number">12</span>]
[<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]
</code></pre>
<p>Cool, it works. How about if we wanted all numbers from 50 to 100 whose
remainder when divided with the number 7 is 3? Easy.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [ x | x &lt;- [<span class="hljs-number">50.</span><span class="hljs-number">.100</span>], x `mod` <span class="hljs-number">7</span> == <span class="hljs-number">3</span>]
[<span class="hljs-number">52</span>,<span class="hljs-number">59</span>,<span class="hljs-number">66</span>,<span class="hljs-number">73</span>,<span class="hljs-number">80</span>,<span class="hljs-number">87</span>,<span class="hljs-number">94</span>]
</code></pre>
<p>Success! Note that weeding out lists by predicates is also called
<em>filtering</em>. We took a list of numbers and we filtered them by the
predicate. Now for another example. Let&apos;s say we want a comprehension
that replaces each odd number greater than 10 with <code>&quot;BANG!&quot;</code> and each odd
number that&apos;s less than 10 with <code>&quot;BOOM!&quot;</code>. If a number isn&apos;t odd, we throw
it out of our list. For convenience, we&apos;ll put that comprehension inside
a function so we can easily reuse it.</p>
<pre><code class="lang-haskell"><span class="hljs-title">boomBangs</span> xs = [ <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;BOOM!&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;BANG!&quot;</span> | x &lt;- xs, odd x]
</code></pre>
<p>The last part of the comprehension is the predicate. The function <code>odd</code>
returns <code>True</code> on an odd number and <code>False</code> on an even one. The element is
included in the list only if all the predicates evaluate to <code>True</code>.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; boomBangs [<span class="hljs-number">7.</span><span class="hljs-number">.13</span>]
[<span class="hljs-string">&quot;BOOM!&quot;</span>,<span class="hljs-string">&quot;BOOM!&quot;</span>,<span class="hljs-string">&quot;BANG!&quot;</span>,<span class="hljs-string">&quot;BANG!&quot;</span>]
</code></pre>
<p>We can include several predicates. If we wanted all numbers from 10 to
20 that are not 13, 15 or 19, we&apos;d do:</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [ x | x &lt;- [<span class="hljs-number">10.</span><span class="hljs-number">.20</span>], x /= <span class="hljs-number">13</span>, x /= <span class="hljs-number">15</span>, x /= <span class="hljs-number">19</span>]
[<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]
</code></pre>
<p>Not only can we have multiple predicates in list comprehensions (an
element must satisfy all the predicates to be included in the resulting
list), we can also draw from several lists. When drawing from several
lists, comprehensions produce all combinations of the given lists and
then join them by the output function we supply. A list produced by a
comprehension that draws from two lists of length 4 will have a length
of 16, provided we don&apos;t filter them. If we have two lists, <code>[2,5,10]</code> and
<code>[8,10,11]</code> and we want to get the products of all the possible
combinations between numbers in those lists, here&apos;s what we&apos;d do.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [ x*y | x &lt;- [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>], y &lt;- [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]]
[<span class="hljs-number">16</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">55</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">110</span>]
</code></pre>
<p>As expected, the length of the new list is 9. What if we wanted all
possible products that are more than 50?</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; [ x*y | x &lt;- [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>], y &lt;- [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>], x*y &gt; <span class="hljs-number">50</span>]
[<span class="hljs-number">55</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">110</span>]
</code></pre>
<p>How about a list comprehension that combines a list of adjectives and a
list of nouns â¦ for epic hilarity.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> nouns = [<span class="hljs-string">&quot;hobo&quot;</span>,<span class="hljs-string">&quot;frog&quot;</span>,<span class="hljs-string">&quot;pope&quot;</span>]
<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> adjectives = [<span class="hljs-string">&quot;lazy&quot;</span>,<span class="hljs-string">&quot;grouchy&quot;</span>,<span class="hljs-string">&quot;scheming&quot;</span>]
<span class="hljs-title">ghci</span>&gt; [adjective ++ <span class="hljs-string">&quot; &quot;</span> ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
[<span class="hljs-string">&quot;lazy hobo&quot;</span>,<span class="hljs-string">&quot;lazy frog&quot;</span>,<span class="hljs-string">&quot;lazy pope&quot;</span>,<span class="hljs-string">&quot;grouchy hobo&quot;</span>,<span class="hljs-string">&quot;grouchy frog&quot;</span>,
<span class="hljs-string">&quot;grouchy pope&quot;</span>,<span class="hljs-string">&quot;scheming hobo&quot;</span>,<span class="hljs-string">&quot;scheming frog&quot;</span>,<span class="hljs-string">&quot;scheming pope&quot;</span>]
</code></pre>
<p>I know! Let&apos;s write our own version of <code>length</code>! We&apos;ll call it <code>length&apos;</code>.</p>
<pre><code class="lang-haskell"><span class="hljs-title">length&apos;</span> xs = sum [<span class="hljs-number">1</span> | _ &lt;- xs]
</code></pre>
<p><code>_</code> means that we don&apos;t care what we&apos;ll draw from the list anyway so
instead of writing a variable name that we&apos;ll never use, we just write
<code>_</code>. This function replaces every element of a list with <code>1</code> and then sums
that up. This means that the resulting sum will be the length of our
list.</p>
<p>Just a friendly reminder: because strings are lists, we can use list
comprehensions to process and produce strings. Here&apos;s a function that
takes a string and removes everything except uppercase letters from it.</p>
<pre><code class="lang-haskell"><span class="hljs-title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&apos;<span class="hljs-type">A&apos;</span>..&apos;<span class="hljs-type">Z&apos;</span>]]
</code></pre>
<p>Testing it out:</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; removeNonUppercase <span class="hljs-string">&quot;Hahaha! Ahahaha!&quot;</span>
<span class="hljs-string">&quot;HA&quot;</span>
<span class="hljs-title">ghci</span>&gt; removeNonUppercase <span class="hljs-string">&quot;IdontLIKEFROGS&quot;</span>
<span class="hljs-string">&quot;ILIKEFROGS&quot;</span>
</code></pre>
<p>The predicate here does all the work. It says that the character will be
included in the new list only if it&apos;s an element of the list <code>[&apos;A&apos;..&apos;Z&apos;]</code>.
Nested list comprehensions are also possible if you&apos;re operating on
lists that contain lists. A list contains several lists of numbers.
Let&apos;s remove all odd numbers without flattening the list.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> xxs = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]]
<span class="hljs-title">ghci</span>&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]
</code></pre>
<p>You can write list comprehensions across several lines. So if you&apos;re not
in GHCI, it&apos;s better to split longer list comprehensions across multiple
lines, especially if they&apos;re nested.</p>
<h2 id="tuples">Tuples</h2>
<p><img src="img/tuple.png" alt="tuples"></p>
<p>In some ways, tuples are like lists â they are a way to store several
values into a single value. However, there are a few fundamental
differences. A list of numbers is a list of numbers. That&apos;s its type and
it doesn&apos;t matter if it has only one number in it or an infinite amount
of numbers. Tuples, however, are used when you know exactly how many
values you want to combine and its type depends on how many components
it has and the types of the components. They are denoted with
parentheses and their components are separated by commas.</p>
<p>Another key difference is that they don&apos;t have to be homogenous. Unlike
a list, a tuple can contain a combination of several types.</p>
<p>Think about how we&apos;d represent a two-dimensional vector in Haskell. One
way would be to use a list. That would kind of work. So what if we
wanted to put a couple of vectors in a list to represent points of a
shape on a two-dimensional plane? We could do something like
<code>[[1,2],[8,11],[4,5]]</code>. The problem with that method is that we could also
do stuff like <code>[[1,2],[8,11,5],[4,5]]</code>, which Haskell has no problem with
since it&apos;s still a list of lists with numbers but it kind of doesn&apos;t
make sense. But a tuple of size two (also called a pair) is its own
type, which means that a list can&apos;t have a couple of pairs in it and
then a triple (a tuple of size three), so let&apos;s use that instead.
Instead of surrounding the vectors with square brackets, we use
parentheses: <code>[(1,2),(8,11),(4,5)]</code>. What if we tried to make a shape like
<code>[(1,2),(8,11,5),(4,5)]</code>? Well, we&apos;d get this error:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Couldn&apos;t</span> match expected <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t</span>, <span class="hljs-title">t1</span>)&apos;</span>
<span class="hljs-title">against</span> inferred <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t2</span>, <span class="hljs-title">t3</span>, <span class="hljs-title">t4</span>)&apos;</span>
<span class="hljs-type">In</span> the expression: (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>)
<span class="hljs-type">In</span> the expression: [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]
<span class="hljs-type">In</span> the definition <span class="hljs-keyword">of</span> `it&apos;: it = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]
</code></pre>
<p>It&apos;s telling us that we tried to use a pair and a triple in the same
list, which is not supposed to happen. You also couldn&apos;t make a list
like <code>[(1,2),(&quot;One&quot;,2)]</code> because the first element of the list is a pair
of numbers and the second element is a pair consisting of a string and a
number. Tuples can also be used to represent a wide variety of data. For
instance, if we wanted to represent someone&apos;s name and age in Haskell,
we could use a triple: <code>(&quot;Christopher&quot;, &quot;Walken&quot;, 55)</code>. As seen in this
example, tuples can also contain lists.</p>
<p>Use tuples when you know in advance how many components some piece of
data should have. Tuples are much more rigid because each different size
of tuple is its own type, so you can&apos;t write a general function to
append an element to a tuple â you&apos;d have to write a function for
appending to a pair, one function for appending to a triple, one
function for appending to a 4-tuple, etc.</p>
<p>While there are singleton lists, there&apos;s no such thing as a singleton
tuple. It doesn&apos;t really make much sense when you think about it. A
singleton tuple would just be the value it contains and as such would
have no benefit to us.</p>
<p>Like lists, tuples can be compared with each other if their components
can be compared. Only you can&apos;t compare two tuples of different sizes,
whereas you can compare two lists of different sizes. Two useful
functions that operate on pairs:</p>
<p><code>fst</code> takes a pair and returns its first component.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; fst (<span class="hljs-number">8</span>,<span class="hljs-number">11</span>)
<span class="hljs-number">8</span>
<span class="hljs-title">ghci</span>&gt; fst (<span class="hljs-string">&quot;Wow&quot;</span>, <span class="hljs-type">False</span>)
<span class="hljs-string">&quot;Wow&quot;</span>
</code></pre>
<p><code>snd</code> takes a pair and returns its second component. Surprise!</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; snd (<span class="hljs-number">8</span>,<span class="hljs-number">11</span>)
<span class="hljs-number">11</span>
<span class="hljs-title">ghci</span>&gt; snd (<span class="hljs-string">&quot;Wow&quot;</span>, <span class="hljs-type">False</span>)
<span class="hljs-type">False</span>
</code></pre>
<blockquote>
<p><em>Note:</em> these functions operate only on pairs. They won&apos;t work on
triples, 4-tuples, 5-tuples, etc. We&apos;ll go over extracting data from
tuples in different ways a bit later.</p>
</blockquote>
<p>A cool function that produces a list of pairs: <code>zip</code>. It takes two lists
and then zips them together into one list by joining the matching
elements into pairs. It&apos;s a really simple function but it has loads of
uses. It&apos;s especially useful for when you want to combine two lists in a
way or traverse two lists simultaneously. Here&apos;s a demonstration.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; zip [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]
[(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)]
<span class="hljs-title">ghci</span>&gt; zip [<span class="hljs-number">1</span> .. <span class="hljs-number">5</span>] [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>]
[(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;one&quot;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;two&quot;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;three&quot;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;four&quot;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;five&quot;</span>)]
</code></pre>
<p>It pairs up the elements and produces a new list. The first element goes
with the first, the second with the second, etc. Notice that because
pairs can have different types in them, <code>zip</code> can take two lists that
contain different types and zip them up. What happens if the lengths of
the lists don&apos;t match?</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; zip [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>] [<span class="hljs-string">&quot;im&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;turtle&quot;</span>]
[(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;im&quot;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;turtle&quot;</span>)]
</code></pre>
<p>The longer list simply gets cut off to match the length of the shorter
one. Because Haskell is lazy, we can zip finite lists with infinite
lists:</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; zip [<span class="hljs-number">1.</span>.] [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>]
[(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;apple&quot;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;orange&quot;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;cherry&quot;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mango&quot;</span>)]
</code></pre>
<p><img src="img/pythag.png" alt="look at meee"></p>
<p>Here&apos;s a problem that combines tuples and list comprehensions: which
right triangle that has integers for all sides and all sides equal to or
smaller than 10 has a perimeter of 24? First, let&apos;s try generating all
triangles with sides equal to or smaller than 10:</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> triangles = [ (a,b,c) | c &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], b &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], a &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>] ]
</code></pre>
<p>We&apos;re just drawing from three lists and our output function is combining
them into a triple. If you evaluate that by typing out <code>triangles</code> in
GHCI, you&apos;ll get a list of all possible triangles with sides under or
equal to 10. Next, we&apos;ll add a condition that they all have to be right
triangles. We&apos;ll also modify this function by taking into consideration
that side b isn&apos;t larger than the hypotenuse and that side a isn&apos;t
larger than side b.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> rightTriangles = [ (a,b,c) | c &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], b &lt;- [<span class="hljs-number">1.</span>.c], a &lt;- [<span class="hljs-number">1.</span>.b], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>]
</code></pre>
<p>We&apos;re almost done. Now, we just modify the function by saying that we
want the ones where the perimeter is 24.</p>
<pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> rightTriangles&apos; = [ (a,b,c) | c &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], b &lt;- [<span class="hljs-number">1.</span>.c], a &lt;- [<span class="hljs-number">1.</span>.b], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>, a+b+c == <span class="hljs-number">24</span>]
<span class="hljs-title">ghci</span>&gt; rightTriangles&apos;
[(<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>)]
</code></pre>
<p>And there&apos;s our answer! This is a common pattern in functional
programming. You take a starting set of solutions and then you apply
transformations to those solutions and filter them until you get the
right ones.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="01-first-things-first.html" class="navigation navigation-prev " aria-label="Previous page: 1. First-Things-First">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="03-types-and-typeclasses.html" class="navigation navigation-next " aria-label="Next page: 3. Types and Typeclasses">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"2. Starting Out ","level":"1.3","depth":1,"next":{"title":"3. Types and Typeclasses","level":"1.4","depth":1,"path":"03-types-and-typeclasses.md","ref":"03-types-and-typeclasses.md","articles":[]},"previous":{"title":"1. First-Things-First","level":"1.2","depth":1,"path":"01-first-things-first.md","ref":"01-first-things-first.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"02-starting-out.md","mtime":"2021-12-25T07:51:19.540Z","type":"markdown"},"gitbook":{"version":"3.6.23","time":"2021-12-25T08:06:05.597Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

